<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TV DO BILL1</title>
<link href="https://vjs.zencdn.net/7.20.2/video-js.css" rel="stylesheet">
<style>
    body { font-family: Arial,sans-serif; margin:0; padding:0; background:#000; color:#fff; display:flex; flex-direction:column; height:100vh; overflow:hidden; }
    #container { display:flex; flex-direction:column; width:100%; height:100%; }
    #main { display:flex; flex:1; overflow:hidden; }
    #player { flex:2; background:rgba(0,0,0,0.8); position:relative; display:flex; justify-content:center; align-items:center; overflow:hidden; }
    .video-js { width:100% !important; height:100% !important; background:#000; }
    #sidebar { flex:1; background:rgba(34,34,34,0.8); overflow-y:auto; padding:10px; border-left:2px solid #ffcc00; }
    #sidebar ul { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:10px; }
    #sidebar li { background:rgba(50,50,50,0.8); border-radius:8px; padding:10px; cursor:pointer; transition:background-color 0.3s; }
    #sidebar li:hover, #sidebar li:focus, #sidebar li.active { background:#ffcc00; color:#000; outline:none; }
    #search-bar { padding:10px; text-align:center; }
    #search-input { width:95%; padding:10px; border:none; border-radius:5px; font-size:1em; }
    .vjs-error-display { display:none !important; }
    ::-webkit-scrollbar { width:16px; }
    ::-webkit-scrollbar-thumb { background:#ffcc00; border-radius:10px; }
    
    /* Indicador de reconexão */
    #reconnect-status {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        display: none;
    }
</style>
</head>
<body>
<div id="container">
    <div id="main">
        <div id="sidebar">
            <div id="search-bar">
                <input type="text" id="search-input" placeholder="Buscar canal...">
            </div>
            <ul id="lista-canais"></ul>
        </div>
        <div id="player">
            <video id="video-player" class="video-js vjs-default-skin" controls playsinline></video>
            <div id="reconnect-status"></div>
        </div>
    </div>
</div>

<script src="https://vjs.zencdn.net/7.20.2/video.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
    const listaURL = "https://raw.githubusercontent.com/listadobill/tv/refs/heads/main/zteste.m3u";
    const listaCanaisElemento = document.getElementById("lista-canais");
    const searchInput = document.getElementById("search-input");
    const reconnectStatus = document.getElementById("reconnect-status");

    const video = videojs('video-player', {
        controls: true,
        autoplay: false,
        preload: 'auto',
        fluid: true,
        responsive: true
    });

    // Variáveis para controle de reconexão
    let currentChannel = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 50; // Aumentado para tentativas quase infinitas
    let reconnectTimeout = null;
    let isManuallyPaused = false;
    let lastPlaybackTime = 0;
    let networkMonitorInterval = null;
    let playbackMonitorInterval = null;

    // Iniciar monitoramento de rede
    startNetworkMonitoring();

    fetch(listaURL)
        .then(r => r.text())
        .then(data => {
            const linhas = data.split('\n');
            const canais = [];

            linhas.forEach((linha, index) => {
                if (linha.startsWith('#EXTINF')) {
                    const nome = linha.split(',')[1].trim();
                    const url = linhas[index + 1];
                    canais.push({ name: nome, url: url });
                }
            });

            canais.sort((a,b) => a.name.localeCompare(b.name,'pt-BR'));

            function renderizarCanais(lista) {
                listaCanaisElemento.innerHTML = '';
                lista.forEach(canal => {
                    const li = document.createElement('li');
                    li.tabIndex = 0;
                    li.textContent = canal.name;
                    li.addEventListener('click', function() {
                        isManuallyPaused = false;
                        currentChannel = canal;
                        reconnectAttempts = 0;
                        loadChannel(canal);
                        // Marca canal ativo
                        document.querySelectorAll('#lista-canais li').forEach(el=>el.classList.remove('active'));
                        li.classList.add('active');
                    });
                    listaCanaisElemento.appendChild(li);
                });
            }

            renderizarCanais(canais);

            searchInput.addEventListener('input', () => {
                const filtro = searchInput.value.toLowerCase();
                const filtrados = canais.filter(c => c.name.toLowerCase().includes(filtro));
                renderizarCanais(filtrados);
            });

            // Navegação por teclado
            listaCanaisElemento.addEventListener('keydown', e => {
                const ativo = document.activeElement;
                if(ativo.tagName.toLowerCase() === 'li'){
                    if(e.key === 'ArrowDown' && ativo.nextElementSibling){
                        ativo.nextElementSibling.focus();
                        ativo.nextElementSibling.scrollIntoView({behavior:'smooth', block:'nearest'});
                        e.preventDefault();
                    }
                    if(e.key === 'ArrowUp' && ativo.previousElementSibling){
                        ativo.previousElementSibling.focus();
                        ativo.previousElementSibling.scrollIntoView({behavior:'smooth', block:'nearest'});
                        e.preventDefault();
                    }
                    if(e.key === 'Enter') ativo.click();
                }
            });

            const primeiro = listaCanaisElemento.querySelector('li');
            if(primeiro) primeiro.focus();
        });

    // Função melhorada para carregar canal
    function loadChannel(channel) {
        if (!channel) return;
        
        console.log('Carregando canal:', channel.name);
        showReconnectStatus('Conectando...');
        
        // Para qualquer reconexão pendente
        if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
            reconnectTimeout = null;
        }
        
        // Configura a fonte do vídeo
        try {
            video.src({ type: 'application/x-mpegURL', src: channel.url });
            video.play().then(() => {
                console.log('Reprodução iniciada com sucesso');
                hideReconnectStatus();
                reconnectAttempts = 0;
                if(video.requestFullscreen) video.requestFullscreen();
            }).catch(error => {
                console.log('Autoplay preventido, tentando reconectar:', error);
                handlePlaybackError(error);
            });
        } catch (error) {
            console.error('Erro ao carregar canal:', error);
            handlePlaybackError(error);
        }
    }

    // Função de reconexão melhorada
    function reconectar() {
        if (!currentChannel || reconnectAttempts >= maxReconnectAttempts) return;
        
        reconnectAttempts++;
        const delay = calculateReconnectDelay(reconnectAttempts);
        
        showReconnectStatus(`Tentativa ${reconnectAttempts} em ${delay/1000}s`);
        
        console.log(`Reconectando em ${delay/1000} segundos (tentativa ${reconnectAttempts})`);
        
        reconnectTimeout = setTimeout(() => {
            if (currentChannel) {
                loadChannel(currentChannel);
            }
        }, delay);
    }

    // Calcula delay com backoff exponencial (3s, 6s, 12s, 24s, ... máximo 60s)
    function calculateReconnectDelay(attempt) {
        const baseDelay = 3000; // 3 segundos
        const maxDelay = 60000; // 60 segundos máximo
        const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), maxDelay);
        return delay;
    }

    // Monitoramento de rede
    function startNetworkMonitoring() {
        // Verifica se estamos online/offline
        window.addEventListener('online', () => {
            console.log('Conexão restaurada');
            if (currentChannel && !isManuallyPaused) {
                reconectar();
            }
        });

        window.addEventListener('offline', () => {
            console.log('Conexão perdida');
            showReconnectStatus('Sem conexão...');
        });

        // Monitoramento contínuo da rede
        networkMonitorInterval = setInterval(() => {
            checkNetworkStatus();
        }, 5000);
    }

    function checkNetworkStatus() {
        fetch('https://httpbin.org/get', { 
            method: 'HEAD',
            cache: 'no-cache'
        }).catch(() => {
            // Em caso de erro, assumimos que há problema de rede
            if (currentChannel && !isManuallyPaused) {
                showReconnectStatus('Problema de rede...');
            }
        });
    }

    // Monitoramento de playback
    function startPlaybackMonitoring() {
        if (playbackMonitorInterval) clearInterval(playbackMonitorInterval);
        
        playbackMonitorInterval = setInterval(() => {
            if (!currentChannel || isManuallyPaused) return;
            
            // Verifica se o vídeo está parado mas deveria estar playing
            if (video.paused() && !isManuallyPaused) {
                console.log('Playback parado inesperadamente, tentando reconectar');
                reconectar();
            }
            
            // Verifica se há buffering prolongado
            if (video.hasClass('vjs-waiting') && !reconnectTimeout) {
                const waitingTime = video.waitingStartedAt ? (Date.now() - video.waitingStartedAt) : 0;
                if (waitingTime > 10000) { // 10 segundos buffering
                    console.log('Buffering prolongado, reconectando');
                    reconectar();
                }
            }
        }, 2000);
    }

    // Manipuladores de eventos do player
    video.on('play', () => {
        isManuallyPaused = false;
        startPlaybackMonitoring();
    });

    video.on('pause', () => {
        isManuallyPaused = true;
    });

    video.on('waiting', () => {
        video.waitingStartedAt = Date.now();
    });

    video.on('playing', () => {
        video.waitingStartedAt = null;
        hideReconnectStatus();
        reconnectAttempts = 0;
    });

    video.on('error', function() {
        if (!isManuallyPaused) {
            handlePlaybackError(video.error());
        }
    });

    video.on('ended', function() {
        // Se o vídeo terminar, trata como erro para recomeçar
        if (!isManuallyPaused && currentChannel) {
            console.log('Stream ended, reconectando');
            reconectar();
        }
    });

    // Função melhorada para tratar erros
    function handlePlaybackError(error) {
        if (isManuallyPaused) return;
        
        console.log('Erro de playback:', error);
        
        // Diferentes tipos de erro podem ter estratégias diferentes
        if (error && error.code === 4) { // MEDIA_ERR_SRC_NOT_SUPPORTED
            console.log('Formato não suportado, tentando forçar recarregamento');
            // Força recarregamento completo
            if (currentChannel) {
                video.src({ type: 'application/x-mpegURL', src: currentChannel.url + '?t=' + Date.now() });
                video.play().catch(() => reconectar());
            }
        } else {
            reconectar();
        }
    }

    // Funções para mostrar/ocultar status de reconexão
    function showReconnectStatus(message) {
        reconnectStatus.textContent = message;
        reconnectStatus.style.display = 'block';
    }

    function hideReconnectStatus() {
        reconnectStatus.style.display = 'none';
    }

    // Limpeza quando a página é fechada
    window.addEventListener('beforeunload', function() {
        if (reconnectTimeout) clearTimeout(reconnectTimeout);
        if (networkMonitorInterval) clearInterval(networkMonitorInterval);
        if (playbackMonitorInterval) clearInterval(playbackMonitorInterval);
    });
});
</script>
</body>
</html>
