<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TV DO BILL - Compatível com Smart TV</title>
<link href="https://vjs.zencdn.net/7.20.2/video-js.css" rel="stylesheet">
<style>
    body { 
        font-family: Arial, sans-serif; 
        margin:0; 
        padding:0; 
        background:#000; 
        color:#fff; 
        display:flex; 
        flex-direction:column; 
        height:100vh; 
        overflow:hidden; 
    }
    #container { 
        display:flex; 
        flex-direction:column; 
        width:100%; 
        height:100%; 
    }
    #main { 
        display:flex; 
        flex:1; 
        overflow:hidden; 
    }
    #player { 
        flex:2; 
        background:rgba(0,0,0,0.8); 
        position:relative; 
        display:flex; 
        justify-content:center; 
        align-items:center; 
        overflow:hidden; 
    }
    .video-js { 
        width:100% !important; 
        height:100% !important; 
        background:#000; 
    }
    #sidebar { 
        flex:1; 
        background:rgba(34,34,34,0.8); 
        overflow-y:auto; 
        padding:10px; 
        border-left:2px solid #ffcc00; 
    }
    #sidebar ul { 
        list-style:none; 
        padding:0; 
        margin:0; 
        display:flex; 
        flex-direction:column; 
        gap:10px; 
    }
    #sidebar li { 
        background:rgba(50,50,50,0.8); 
        border-radius:8px; 
        padding:10px; 
        cursor:pointer; 
        transition:background-color 0.3s; 
    }
    #sidebar li:hover, #sidebar li:focus, #sidebar li.active { 
        background:#ffcc00; 
        color:#000; 
        outline:none; 
    }
    #search-bar { 
        padding:10px; 
        text-align:center; 
    }
    #search-input { 
        width:95%; 
        padding:10px; 
        border:none; 
        border-radius:5px; 
        font-size:1em; 
    }
    .vjs-error-display { 
        display:none !important; 
    }
    ::-webkit-scrollbar { 
        width:16px; 
    }
    ::-webkit-scrollbar-thumb { 
        background:#ffcc00; 
        border-radius:10px; 
    }
    
    /* Sistema simplificado de notificação */
    #error-system {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 300px;
    }
    
    .error-notification {
        background: rgba(200, 0, 0, 0.9);
        color: white;
        padding: 12px;
        border-radius: 6px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    /* Tela de erro simplificada */
    #error-display {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.9);
        z-index: 999;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 20px;
        text-align: center;
    }
    
    #error-display.visible {
        display: flex;
    }
    
    #error-display h2 {
        color: #ff3333;
        margin: 0 0 15px 0;
    }
    
    #error-display .error-actions {
        display: flex;
        gap: 10px;
        margin-top: 20px;
    }
    
    #error-display button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    
    #loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        z-index: 998;
        display: none;
        justify-content: center;
        align-items: center;
    }
    
    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top-color: #ffcc00;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
</head>
<body>
<div id="container">
    <div id="main">
        <div id="sidebar">
            <div id="search-bar">
                <input type="text" id="search-input" placeholder="Buscar canal...">
            </div>
            <ul id="lista-canais"></ul>
        </div>
        <div id="player">
            <video id="video-player" class="video-js vjs-default-skin" controls playsinline></video>
            
            <div id="error-display">
                <h2 id="error-title">Erro ao Carregar Conteúdo</h2>
                <p id="error-message">Não foi possível carregar o conteúdo solicitado.</p>
                <div class="error-actions">
                    <button id="retry-button">Tentar Novamente</button>
                    <button id="change-channel-button">Escolher Outro Canal</button>
                </div>
            </div>
            
            <div id="loading-overlay">
                <div class="spinner"></div>
            </div>
        </div>
    </div>
</div>

<!-- Sistema de notificação de erros -->
<div id="error-system"></div>

<script src="https://vjs.zencdn.net/7.20.2/video.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
    const listaURL = "https://raw.githubusercontent.com/listadobill/tv/refs/heads/main/zteste.m3u";
    const listaCanaisElemento = document.getElementById("lista-canais");
    const searchInput = document.getElementById("search-input");
    const errorDisplay = document.getElementById("error-display");
    const errorTitle = document.getElementById("error-title");
    const errorMessage = document.getElementById("error-message");
    const retryButton = document.getElementById("retry-button");
    const changeChannelButton = document.getElementById("change-channel-button");
    const loadingOverlay = document.getElementById("loading-overlay");
    const errorSystem = document.getElementById('error-system');

    let canais = [];
    let currentChannel = null;
    let reconnectCount = 0;
    let errorTimeout = null;

    const video = videojs('video-player', {
        controls: true,
        autoplay: false,
        preload: 'auto',
        fluid: true,
        responsive: true
    });

    // Função para mostrar notificação de erro
    function showErrorNotification(message, type = 'error') {
        const notification = document.createElement('div');
        notification.className = `error-notification`;
        notification.innerHTML = `
            <div>${message}</div>
        `;
        
        errorSystem.appendChild(notification);
        
        // Remover automaticamente após 5 segundos
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
    }

    // Função para mostrar tela de erro
    function showError(title, message) {
        errorTitle.textContent = title;
        errorMessage.textContent = message;
        errorDisplay.classList.add('visible');
    }

    // Função para ocultar tela de erro
    function hideError() {
        errorDisplay.classList.remove('visible');
    }

    // Função para mostrar loading
    function showLoading() {
        loadingOverlay.style.display = 'flex';
    }

    // Função para ocultar loading
    function hideLoading() {
        loadingOverlay.style.display = 'none';
    }

    // Configurar eventos de botão
    retryButton.addEventListener('click', function() {
        hideError();
        if (currentChannel) {
            loadChannel(currentChannel);
        }
    });

    changeChannelButton.addEventListener('click', function() {
        hideError();
        const firstChannel = listaCanaisElemento.querySelector('li');
        if (firstChannel) firstChannel.focus();
    });

    // Função para carregar um canal - MANTIDA A LÓGICA ORIGINAL
    function loadChannel(channel) {
        currentChannel = channel;
        reconnectCount = 0;
        
        showLoading();
        
        // Lógica original que funciona na Smart TV
        video.src({ type: 'application/x-mpegURL', src: channel.url });
        video.play().catch(error => {
            console.error('Erro ao reproduzir vídeo:', error);
            handleVideoError('Erro ao reproduzir o vídeo', error);
        });
        
        // Marca canal ativo
        document.querySelectorAll('#lista-canais li').forEach(el => el.classList.remove('active'));
        const activeLi = Array.from(listaCanaisElemento.querySelectorAll('li')).find(li => 
            li.textContent.includes(channel.name) || li.textContent === channel.name
        );
        if (activeLi) activeLi.classList.add('active');
    }

    // Função para tratar erros de vídeo - MANTIDA A LÓGICA ORIGINAL
    function handleVideoError(context, error) {
        console.error(`${context}:`, error);
        
        showErrorNotification('Erro de reprodução. Tentando reconectar...');
        
        // Reconexão a cada 3 segundos (conforme solicitado)
        if (errorTimeout) clearTimeout(errorTimeout);
        errorTimeout = setTimeout(() => {
            if (currentChannel) {
                loadChannel(currentChannel);
            }
        }, 3000);
    }

    // CARREGAMENTO DA LISTA - MANTIDO O MÉTODO ORIGINAL QUE FUNCIONA
    showLoading();
    
    // Primeiro tenta com fetch
    fetch(listaURL)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Erro HTTP ${response.status}`);
            }
            return response.text();
        })
        .then(data => {
            processChannelData(data);
        })
        .catch(error => {
            console.error('Erro com fetch, tentando XHR:', error);
            // Fallback para XHR como no original
            loadChannelListWithXHR();
        });

    // Fallback para XHR
    function loadChannelListWithXHR() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', listaURL);
        xhr.timeout = 10000;
        
        xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
                processChannelData(xhr.responseText);
            } else {
                showErrorNotification('Erro ao carregar lista de canais');
                loadDefaultChannels();
            }
        };
        
        xhr.onerror = xhr.ontimeout = function() {
            showErrorNotification('Erro de conexão ao carregar canais');
            loadDefaultChannels();
        };
        
        try {
            xhr.send();
        } catch (e) {
            console.error('Exceção ao carregar lista:', e);
            loadDefaultChannels();
        }
    }

    // Canais padrão se não carregar
    function loadDefaultChannels() {
        canais = [
            { name: 'Canal Exemplo 1', url: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8' },
            { name: 'Canal Exemplo 2', url: 'https://cph-p2p-msl.akamaized.net/hls/live/2000341/test/master.m3u8' }
        ];
        renderCanais(canais);
        hideLoading();
    }

    // Processar dados da lista de canais - MÉTODO ORIGINAL
    function processChannelData(data) {
        const linhas = data.split('\n');
        const canaisTemp = [];

        for (let i = 0; i < linhas.length; i++) {
            const linha = linhas[i];
            if (linha.startsWith('#EXTINF')) {
                const nome = linha.split(',')[1] ? linha.split(',')[1].trim() : 'Canal Desconhecido';
                const url = linhas[i + 1];
                if (url && !url.startsWith('#') && url.trim() !== '') {
                    canaisTemp.push({ 
                        name: nome, 
                        url: url.trim()
                    });
                }
            }
        }

        canais = canaisTemp.sort((a, b) => a.name.localeCompare(b.name, 'pt-BR'));
        renderCanais(canais);
        hideLoading();
    }

    // Função para renderizar a lista de canais - MÉTODO ORIGINAL SIMPLIFICADO
    function renderCanais(lista) {
        listaCanaisElemento.innerHTML = '';
        lista.forEach(canal => {
            const li = document.createElement('li');
            li.tabIndex = 0;
            li.textContent = canal.name;
            li.addEventListener('click', function() {
                // **LÓGICA ORIGINAL QUE FUNCIONA NA SMART TV**
                loadChannel(canal);
                
                // Tela cheia como no original
                if (video.requestFullscreen) {
                    video.requestFullscreen().catch(e => console.log('Fullscreen não suportado:', e));
                }
            });
            listaCanaisElemento.appendChild(li);
        });

        // Navegação por teclado - MÉTODO ORIGINAL
        listaCanaisElemento.addEventListener('keydown', e => {
            const ativo = document.activeElement;
            if (ativo.tagName.toLowerCase() === 'li') {
                if (e.key === 'ArrowDown' && ativo.nextElementSibling) {
                    ativo.nextElementSibling.focus();
                    e.preventDefault();
                }
                if (e.key === 'ArrowUp' && ativo.previousElementSibling) {
                    ativo.previousElementSibling.focus();
                    e.preventDefault();
                }
                if (e.key === 'Enter') ativo.click();
            }
        });

        // Focar no primeiro canal
        const primeiro = listaCanaisElemento.querySelector('li');
        if (primeiro) primeiro.focus();
    }

    // Configurar busca - MÉTODO ORIGINAL
    searchInput.addEventListener('input', () => {
        const filtro = searchInput.value.toLowerCase();
        const filtrados = canais.filter(c => c.name.toLowerCase().includes(filtro));
        renderCanais(filtrados);
    });

    // Configurar event listeners para o player de vídeo
    video.on('loadstart', function() {
        showLoading();
    });

    video.on('loadeddata', function() {
        hideLoading();
        hideError();
    });

    video.on('waiting', function() {
        showLoading();
    });

    video.on('playing', function() {
        hideLoading();
    });

    video.on('error', function() {
        const error = video.error();
        handleVideoError('Erro no player de vídeo', error);
    });
});
</script>
</body>
</html>
